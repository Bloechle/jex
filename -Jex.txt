# Jex Project Overview

## 1. Development Guidelines
- Keep code **clean, simple, and optimized**.
- Prioritize **clarity over cleverness**; avoid unnecessary complexity.
- Maintain **consistent and meaningful naming conventions**.
- Use **English** for all code and documentation.
- Use **Vanilla JavaScript only** (**NO React**).
- Use **Tailwind CSS** for styling.
- Use **Jex.js** for DOM manipulation and debug logging.
- Each class should have a comprehensive documentation header.
- Use private fields/methods with # prefix where appropriate.

## 2. AI Instructions
- Do NOT give an instant analysis of this overview in the chat!
- Simply respond with "OK, I'm ready :-)" after processing this overview.
- And wait for further chat request about the project.

## 3. Configuration
- **Project Name:** Jex
- **Ignored Paths:** LICENCE, -scanner.js, -Jex.txt, node_modules, .git, dist, build, .idea
- **Accepted File Extensions:** .js, .css, .html, .jsx, .ts, .tsx, .json, .md
- **Generated on:** 2025-09-16T06:31:27.677Z
- **Max File Size:** 10.00 MB
- **Include Hashes:** Yes
- **Include Line Count:** Yes

## 4. Directory Structure

The following tree represents the complete project structure:Jex/
├── util/
├── .gitignore (17.00 B)
├── jex-logo.svg (5.50 KB)
├── Jex.js (31.59 KB)
├── JexInspector.js (17.51 KB)
├── JexLogger.js (24.11 KB)
├── JexToast.js (16.27 KB)
├── LICENSE (1.07 KB)
└── README.md (5.74 KB)



## 5. File Content
Below are the contents of all processed files in the project:


================================================================================
FILE: Jex.js
Type: JS
Size: 31.59 KB
Last Modified: 2025-09-12T08:11:35.886Z
Lines: 1027
MD5: 52d12dbd96d271e39af3a2289f47d71b
================================================================================

/**
 * Jex.js - Lightweight DOM Manipulation Library
 *
 * A modern, jQuery-like library for DOM manipulation with zero dependencies.
 * Provides an intuitive API for element selection, manipulation, and event handling.
 *
 * FEATURES:
 * ---------
 * - Lightweight and fast with no external dependencies
 * - jQuery-like syntax for familiar development experience
 * - Supports method chaining for cleaner code
 * - Built-in event delegation and cleanup
 * - Works with both HTML and SVG elements
 * - Modern ES6+ class-based architecture
 * - TypeScript-friendly with JSDoc annotations
 *
 * BASIC USAGE:
 * -----------
 * import { jex, Jex } from './Jex.js';
 *
 * // Select and manipulate elements
 * jex.$('myButton').cls('+active').text('Click me!');
 *
 * // Create new elements
 * const div = jex.create('div').cls('container').html('<p>Hello!</p>');
 *
 * // Event handling with automatic cleanup
 * const cleanup = jex.onDocument('click', (e) => console.log('Clicked!'));
 *
 * // Select element by CSS selector
 * jex.select('.header').cls('+highlight');
 *
 * // Find multiple elements within a container
 * const container = jex.$('myContainer');
 * container.find('.item').cls('+highlight').on('click', handler);
 *
 * PUBLIC API:
 * ----------
 * Classes:
 *   - Jex: Main DOM wrapper class for single elements
 *   - JexCollection: Array-like class for handling multiple elements
 *
 * Global Instance:
 *   - jex: Pre-initialized Jex instance for immediate use
 *
 * Version:
 *   - JEX_VERSION: Current library version string
 *
 * @author TOPLabs
 * @license MIT
 * @version 2025.07.02
 */

// Version constant
export const JEX_VERSION = '2025.07.02';

/////////////////////////
// Core DOM API Classes
/////////////////////////

/**
 * Collection class for batch DOM operations
 * @extends Array
 */
export class JexCollection extends Array {
    /**
     * Create a new JexCollection
     * @param {Jex[]} items - Array of Jex instances
     */
    constructor(items = []) {
        super(...items);
        const methods = [
            'on', 'off', 'cls', 'attr', 'props', 'style', 'html',
            'text', 'value', 'append', 'prepend', 'clear', 'dim',
            'clearCls', 'timeCls', 'fadeIn', 'fadeOut', 'show', 'hide'
        ];

        methods.forEach(method => {
            this[method] = (...args) => {
                this.forEach(item => {
                    if (item[method]) item[method](...args);
                });
                return this;
            };
        });
    }

    /**
     * Filter collection items
     * @param {Function} fn - Filter function
     * @returns {JexCollection} Filtered collection
     */
    filter(fn) {
        return new JexCollection(super.filter(fn));
    }

    /**
     * Get first element in collection
     * @returns {Jex|null} First Jex instance or null
     */
    first() {
        return this[0] || null;
    }

    /**
     * Get last element in collection
     * @returns {Jex|null} Last Jex instance or null
     */
    last() {
        return this[this.length - 1] || null;
    }
}

/**
 * Main DOM manipulation class
 */
export class Jex {
    #ref;
    #doc;
    #isSvg;
    #eventHandlers = new Map();

    /**
     * Create a new Jex instance
     * @param {string|HTMLElement|SVGElement|Jex} tag - Element tag name, DOM element, or Jex instance
     */
    constructor(tag = document.documentElement) {
        if (tag instanceof Jex) {
            this.#ref = tag.ref;
        } else if (typeof tag === 'object' && typeof tag.addEventListener === 'function') {
            this.#ref = tag;
        } else if (typeof tag === 'string') {
            this.#ref = document.createElement(tag);
        } else {
            this.#ref = document.documentElement;
        }
        this.#doc = this.#ref.ownerDocument;
        this.#isSvg = this.#ref instanceof SVGElement;
    }

    /**
     * Get the wrapped DOM element
     * @returns {HTMLElement|SVGElement} The wrapped element
     */
    get ref() {
        return this.#ref;
    }

    /**
     * Alias for ref
     * @returns {HTMLElement|SVGElement} The wrapped element
     */
    get element() {
        return this.#ref;
    }

    /**
     * Check if element exists in DOM
     * @returns {boolean} True if element has a parent node
     */
    exists() {
        return this.#ref && this.#ref.parentNode !== null;
    }

    /**
     * Check if element is visible
     * @returns {boolean} True if element is visible
     */
    isVisible() {
        if (!this.#ref) return false;
        const style = window.getComputedStyle(this.#ref);
        return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
    }

    /**
     * Remove element from DOM and clean up event handlers
     * @param {string} [id] - Optional ID of element to remove
     * @returns {Jex} This instance for chaining
     */
    remove(id) {
        if (id) {
            // Remove element by ID
            const element = this.$(id);
            element?.remove();
            return this;
        }

        // Remove current element
        // Clean up event handlers
        this.#eventHandlers.forEach((handlers, event) => {
            handlers.forEach(handler => {
                this.#ref.removeEventListener(event, handler.fn, handler.options);
            });
        });
        this.#eventHandlers.clear();

        if (this.#ref && this.#ref.parentNode) {
            this.#ref.remove();
        }
        return this;
    }

    /**
     * Get parent element
     * @returns {Jex|null} Parent element wrapped in Jex or null
     */
    parent() {
        return this.#ref.parentElement ? new Jex(this.#ref.parentElement) : null;
    }

    /**
     * Find closest ancestor matching selector
     * @param {string} selector - CSS selector
     * @returns {Jex|null} Closest element wrapped in Jex or null
     */
    closest(selector) {
        const el = this.#ref.closest(selector);
        return el ? new Jex(el) : null;
    }

    /**
     * Trigger click on element
     * @returns {Jex} This instance for chaining
     */
    click() {
        if (this.#ref && typeof this.#ref.click === 'function') {
            this.#ref.click();
        }
        return this;
    }

    /**
     * Focus element
     * @returns {Jex} This instance for chaining
     */
    focus() {
        if (this.#ref && typeof this.#ref.focus === 'function') {
            this.#ref.focus();
        }
        return this;
    }

    /**
     * Blur element
     * @returns {Jex} This instance for chaining
     */
    blur() {
        if (this.#ref && typeof this.#ref.blur === 'function') {
            this.#ref.blur();
        }
        return this;
    }

    id(id)
    {
        return this.$(id)
    }

    /**
     * Select element by ID
     * @param {string} id - Element ID (with or without #)
     * @returns {Jex|null|boolean} Element wrapped in Jex, null if not found, or boolean if id starts with '?'
     */
    $(id) {
        if (!id) {
            console.warn('Jex.$(): ID parameter is empty or undefined');
            return null;
        }

        const checkExists = id.startsWith('?');
        if (checkExists) {
            id = id.substring(1);
        }

        const el = this.#doc.getElementById(id.startsWith('#') ? id.substring(1) : id);

        if (checkExists) {
            return el !== null;
        }

        if (!el) {
            console.warn(`Jex.$(): Element with id "${id}" not found`);
        }

        return el ? new Jex(el) : null;
    }

    /**
     * Select first child element matching selector
     * @param {string} selector - CSS selector
     * @returns {Jex|null} First matching element wrapped in Jex or null
     */
    select(selector) {
        if (!selector || typeof selector !== 'string') {
            console.warn('Jex.select: Invalid selector provided');
            return null;
        }

        try {
            const el = this.#ref.querySelector(selector);
            if (!el) {
                console.warn(`Jex.select - Element not found: ${selector}`);
                return null;
            }
            return new Jex(el);
        } catch (e) {
            console.error(`Jex.select: Invalid selector syntax: ${selector}`);
            return null;
        }
    }

    /**
     * Find all child elements matching selector
     * @param {string} selector - CSS selector
     * @returns {JexCollection} Collection of matching elements
     */
    find(selector) {
        if (!selector || typeof selector !== 'string') {
            console.warn('Jex.find: Invalid selector provided');
            return new JexCollection();
        }

        try {
            return new JexCollection(
                Array.from(this.#ref.querySelectorAll(selector))
                    .map(el => new Jex(el))
            );
        } catch (e) {
            console.error(`Jex.find: Invalid selector syntax: ${selector}`);
            return new JexCollection();
        }
    }

    /**
     * Create new element
     * @param {string} tag - Element tag name
     * @param {string|null} id - Optional element ID
     * @param {boolean} svg - Whether to create SVG element
     * @returns {Jex} New element wrapped in Jex
     */
    create(tag, id = null, svg = false) {
        if (!tag || typeof tag !== 'string') {
            console.error('Jex.create: Tag name must be a non-empty string');
            return new Jex(document.createElement('div'));
        }

        try {
            const jx = new Jex(
                svg ? this.#doc.createElementNS('http://www.w3.org/2000/svg', tag)
                    : this.#doc.createElement(tag)
            );

            if (id !== null) {
                jx.attr('id', id);
            }

            return jx;
        } catch (e) {
            console.error(`Jex.create: Failed to create element "${tag}":`, e);
            return new Jex(document.createElement('div'));
        }
    }

    /**
     * Create and append new element
     * @param {string} tag - Element tag name
     * @param {string|null} id - Optional element ID
     * @param {boolean} svg - Whether to create SVG element
     * @returns {Jex} New element wrapped in Jex
     */
    add(tag, id = null, svg = false) {
        const jx = this.create(tag, id, svg);
        this.append(jx);
        return jx;
    }

    /**
     * Append elements to this element
     * @param {...(Jex|Node|string)} elements - Elements to append
     * @returns {Jex} This instance for chaining
     */
    append(...elements) {
        if (!this.#ref) {
            console.error('Jex.append: Cannot append to null reference');
            return this;
        }

        elements.forEach(el => {
            try {
                if (el instanceof Jex) {
                    this.#ref.appendChild(el.ref);
                } else if (el instanceof Node) {
                    this.#ref.appendChild(el);
                } else if (typeof el === 'string') {
                    this.#ref.insertAdjacentHTML('beforeend', el);
                } else {
                    console.warn('Jex.append: Skipping non-Node element:', el);
                }
            } catch (e) {
                console.error('Jex.append: Failed to append element:', e);
            }
        });
        return this;
    }

    /**
     * Prepend elements to this element
     * @param {...(Jex|Node|string)} elements - Elements to prepend
     * @returns {Jex} This instance for chaining
     */
    prepend(...elements) {
        if (!this.#ref) {
            console.error('Jex.prepend: Cannot prepend to null reference');
            return this;
        }

        elements.reverse().forEach(el => {
            try {
                if (el instanceof Jex) {
                    this.#ref.insertBefore(el.ref, this.#ref.firstChild);
                } else if (el instanceof Node) {
                    this.#ref.insertBefore(el, this.#ref.firstChild);
                } else if (typeof el === 'string') {
                    this.#ref.insertAdjacentHTML('afterbegin', el);
                }
            } catch (e) {
                console.error('Jex.prepend: Failed to prepend element:', e);
            }
        });
        return this;
    }

    /**
     * Mount element to parent
     * @param {Jex|HTMLElement|SVGElement} parent - Parent element
     * @returns {Jex} This instance for chaining
     */
    mount(parent) {
        if (!parent) {
            console.error('Jex.mount: Parent element is required');
            return this;
        }

        try {
            if (parent instanceof Jex) {
                parent.ref.appendChild(this.#ref);
            } else if (parent instanceof HTMLElement || parent instanceof SVGElement) {
                parent.appendChild(this.#ref);
            } else {
                console.error('Jex.mount: Parent must be a Jex instance or DOM element');
            }
        } catch (e) {
            console.error('Jex.mount: Failed to mount element:', e);
        }
        return this;
    }

    /**
     * Mount element to document body
     * @returns {Jex} This instance for chaining
     */
    mountToBody() {
        return this.mount(this.#doc.body);
    }

    /**
     * Mount element to document head
     * @returns {Jex} This instance for chaining
     */
    mountToHead() {
        return this.mount(this.#doc.head);
    }

    /**
     * Inject styles into the document head with a unique ID
     * @param {string} id - Unique ID for the style element
     * @param {string|Function} styles - CSS style rules or function returning CSS
     */
    injectStyles(id, styles) {
        if (!jex.$(`?${id}`)) {
            const css = typeof styles === 'function' ? styles() : styles;
            jex.create('style', id)
                .text(css)
                .mountToHead();
        }
    }

    /**
     * Get/set attributes
     * @param {string|Object} name - Attribute name or object of attributes
     * @param {string} [value] - Attribute value
     * @returns {Jex|string|null} This instance for chaining or attribute value
     */
    attr(name, value) {
        if (!this.#ref) return this;

        if (typeof name === 'object') {
            Object.entries(name).forEach(([k, v]) => this.attr(k, v));
            return this;
        }

        if (value === undefined) {
            return this.#ref.getAttribute(name);
        }

        if (value === null) {
            this.#ref.removeAttribute(name);
        } else {
            try {
                this.#ref.setAttribute(name, value);
            } catch (e) {
                console.error(`Jex.attr: Failed to set attribute "${name}":`, e);
            }
        }
        return this;
    }

    /**
     * Get/set properties
     * @param {string|Object} name - Property name or object of properties
     * @param {*} [value] - Property value
     * @returns {Jex|*} This instance for chaining or property value
     */
    props(name, value) {
        if (!this.#ref) return this;

        if (typeof name === 'object') {
            Object.entries(name).forEach(([k, v]) => this.props(k, v));
            return this;
        }

        if (value === undefined) {
            return this.#ref[name];
        }

        try {
            this.#ref[name] = value;
        } catch (e) {
            console.error(`Jex.props: Failed to set property "${name}":`, e);
        }
        return this;
    }

    /**
     * Get/set styles
     * @param {string|Object} name - Style property name or object of styles
     * @param {string} [value] - Style value
     * @returns {Jex|string} This instance for chaining or style value
     */
    style(name, value) {
        if (!this.#ref || !this.#ref.style) return this;

        if (typeof name === 'object') {
            Object.assign(this.#ref.style, name);
        } else if (value === undefined) {
            return this.#ref.style[name];
        } else {
            this.#ref.style[name] = value;
        }
        return this;
    }

    /**
     * Clear all classes and optionally add new ones
     * @param {...string} classes - Classes to add after clearing
     * @returns {Jex} This instance for chaining
     */
    clearCls(...classes) {
        if (this.#ref) {
            this.#ref.className = '';
        }
        return this.cls(...classes);
    }

    /**
     * Add class temporarily
     * @param {string} className - Class to add
     * @param {number} duration - Duration in milliseconds
     * @returns {Jex} This instance for chaining
     */
    timeCls(className, duration = 1000) {
        if (!className || !this.#ref) return this;

        this.cls(className);

        setTimeout(() => {
            if (this.#ref && this.#ref.parentNode) {
                this.cls(`-${className}`);
            }
        }, duration);

        return this;
    }

    /**
     * Manipulate classes with special syntax
     * @param {...string} classes - Classes with optional prefixes (+add, -remove, ~toggle, ?check)
     * @returns {Jex|boolean} This instance for chaining or boolean for ?check
     */
    cls(...classes) {
        if (!this.#ref || !this.#ref.classList) return this;

        if (!classes.length || classes[0] === undefined) {
            return this.#ref.classList;
        }

        const list = this.#ref.classList;
        const actions = {
            '-': name => name && list.remove(name),
            '~': name => name && list.toggle(name),
            '+': name => name && list.add(name),
            '?': name => name && list.contains(name)
        };

        const tokens = classes.join(' ').replace(/,/g, ' ').split(/\s+/).filter(Boolean);

        for (const cls of tokens) {
            const action = actions[cls[0]];
            if (action) {
                const result = action(cls.slice(1));
                // Return boolean for '?' queries
                if (cls[0] === '?') return result;
            } else {
                list.add(cls);
            }
        }

        return this;
    }

    /**
     * Get/set innerHTML
     * @param {string} [content] - HTML content
     * @returns {Jex|string} This instance for chaining or current HTML
     */
    html(content) {
        if (!this.#ref) return this;

        if (content === undefined) return this.#ref.innerHTML;

        try {
            this.#ref.innerHTML = content;
        } catch (e) {
            console.error('Jex.html: Failed to set innerHTML:', e);
        }
        return this;
    }

    /**
     * Get/set text content
     * @param {string} [content] - Text content
     * @returns {Jex|string} This instance for chaining or current text
     */
    text(content) {
        if (!this.#ref) return this;

        if (content === undefined) return this.#ref.textContent;
        this.#ref.textContent = content;
        return this;
    }

    /**
     * Get/set input value
     * @param {string} [val] - Value
     * @returns {Jex|string} This instance for chaining or current value
     */
    value(val) {
        if (!this.#ref) return this;

        if (val === undefined) return this.#ref.value;
        this.#ref.value = val;
        return this;
    }

    /**
     * Get/set data attributes
     * @param {string} key - Data attribute key (without data- prefix)
     * @param {string} [value] - Data value
     * @returns {Jex|string} This instance for chaining or data value
     */
    data(key, value) {
        if (!this.#ref) return this;

        if (value === undefined) {
            const attr = this.#ref.getAttribute(`data-${key}`);
            return attr === null ? "" : attr;
        } else {
            this.#ref.setAttribute(`data-${key}`, value);
            return this;
        }
    }

    /**
     * Clear element content
     * @returns {Jex} This instance for chaining
     */
    clear() {
        if (!this.#ref) return this;

        if (this.#isSvg) {
            while (this.#ref.firstChild) {
                this.#ref.removeChild(this.#ref.firstChild);
            }
        } else {
            this.#ref.innerHTML = '';
        }
        return this;
    }

    /**
     * Enable or disable element
     * @param {boolean} [enabled=true] - Whether to enable the element
     * @returns {Jex} This instance for chaining
     */
    enable(enabled = true) {
        return  this.props('disabled', !enabled);
    }

    /**
     * Disable element (convenience method)
     * @returns {Jex} This instance for chaining
     */
    disable() {
        return this.enable(false);
    }

    /**
     * Add event listener
     * @param {string} event - Event name (prefix with - to remove)
     * @param {Function} handler - Event handler
     * @param {boolean|Object} [options] - Event options
     * @returns {Jex} This instance for chaining
     */
    on(event, handler, options) {
        if (!this.#ref || !event || !handler) return this;

        try {
            if (event.startsWith('-')) {
                // Remove event listener
                this.off(event.slice(1), handler);
            } else {
                // Store handler reference for later removal
                if (!this.#eventHandlers.has(event)) {
                    this.#eventHandlers.set(event, []);
                }
                this.#eventHandlers.get(event).push({fn: handler, options});

                this.#ref.addEventListener(event, handler, options);
            }
        } catch (e) {
            console.error(`Jex.on: Failed to ${event.startsWith('-') ? 'remove' : 'add'} event listener:`, e);
        }
        return this;
    }

    /**
     * Remove event listener
     * @param {string} event - Event name
     * @param {Function} [handler] - Event handler (removes all if not provided)
     * @returns {Jex} This instance for chaining
     */
    off(event, handler) {
        if (!this.#ref || !event) return this;

        const handlers = this.#eventHandlers.get(event);
        if (handlers) {
            if (handler) {
                // Remove specific handler
                const index = handlers.findIndex(h => h.fn === handler);
                if (index !== -1) {
                    const h = handlers[index];
                    this.#ref.removeEventListener(event, h.fn, h.options);
                    handlers.splice(index, 1);
                }
            } else {
                // Remove all handlers for this event
                handlers.forEach(h => {
                    this.#ref.removeEventListener(event, h.fn, h.options);
                });
                this.#eventHandlers.delete(event);
            }
        }
        return this;
    }

    /**
     * Add click event listener
     * @param {Function} handler - Click handler
     * @param {Object} [options={}] - Event options
     * @param {boolean} [options.preventDefault=false] - Whether to prevent default
     * @returns {Jex} This instance for chaining
     */
    onClick(handler, options = {}) {
        if (!handler || typeof handler !== 'function') {
            console.error('Jex.onClick: Handler must be a function');
            return this;
        }

        const {preventDefault = false, ...eventOptions} = options;
        this.on('click', (event) => {
            if (preventDefault) {
                event.preventDefault();
            }
            handler(event);
        }, eventOptions);
        return this;
    }

    /**
     * Set up event delegation
     * @param {string} event - Event name
     * @param {string} selector - CSS selector for target elements
     * @param {Function} handler - Event handler
     * @param {boolean|Object} [options] - Event options
     * @returns {Jex} This instance for chaining
     */
    delegate(event, selector, handler, options) {
        this.on(event, (e) => {
            const target = e.target.closest(selector);
            if (target && this.#ref.contains(target)) {
                handler.call(target, e);
            }
        }, options);
        return this;
    }

    /**
     * Show element
     * @returns {Jex} This instance for chaining
     */
    show() {
        if (this.#ref) {
            this.#ref.style.display = '';
        }
        return this;
    }

    /**
     * Hide element
     * @returns {Jex} This instance for chaining
     */
    hide() {
        if (this.#ref) {
            this.#ref.style.display = 'none';
        }
        return this;
    }

    /**
     * Get/set element dimensions
     * @param {string} prop - Dimension property (width, height, etc.)
     * @param {string|number} [value] - Dimension value
     * @returns {Jex|number} This instance for chaining or dimension value
     */
    dim(prop, value) {
        if (!this.#ref) return this;

        if (value === undefined) {
            const rect = this.#ref.getBoundingClientRect();
            return rect[prop];
        }

        this.style(prop, typeof value === 'number' ? `${value}px` : value);
        return this;
    }

    /**
     * Check if element contains child
     * @param {Jex|HTMLElement|SVGElement} child - Child element
     * @returns {boolean} True if contains child
     */
    contains(child) {
        if (!this.#ref || !child) return false;
        const childEl = child instanceof Jex ? child.ref : child;
        return this.#ref.contains(childEl);
    }

    /**
     * Get element index among siblings
     * @returns {number} Element index or -1
     */
    index() {
        if (!this.#ref || !this.#ref.parentNode) return -1;
        return Array.from(this.#ref.parentNode.children).indexOf(this.#ref);
    }

    /**
     * Get sibling elements
     * @returns {JexCollection} Collection of siblings
     */
    siblings() {
        if (!this.#ref || !this.#ref.parentNode) return new JexCollection();

        const siblings = Array.from(this.#ref.parentNode.children)
            .filter(el => el !== this.#ref)
            .map(el => new Jex(el));

        return new JexCollection(siblings);
    }

    /**
     * Get next sibling element
     * @returns {Jex|null} Next sibling wrapped in Jex or null
     */
    next() {
        return this.#ref.nextElementSibling ? new Jex(this.#ref.nextElementSibling) : null;
    }

    /**
     * Get previous sibling element
     * @returns {Jex|null} Previous sibling wrapped in Jex or null
     */
    prev() {
        return this.#ref.previousElementSibling ? new Jex(this.#ref.previousElementSibling) : null;
    }

    /**
     * Add event listener(s) to the document
     * @param {string|Object} eventOrEvents - Event name or object with event:handler pairs
     * @param {Function|boolean|Object} handlerOrOptions - Handler function (if first param is string) or options (if first param is object)
     * @param {boolean|Object} [options={ passive: true }] - Event options (only if first param is string)
     * @returns {Function} Cleanup function to remove all added listeners
     */
    onDocument(eventOrEvents, handlerOrOptions, options = {passive: true}) {
        const doc = this.#doc || document;
        const listeners = [];

        // Handle multiple events case
        if (typeof eventOrEvents === 'object' && eventOrEvents !== null) {
            // eventOrEvents is { 'mouseover': handler1, 'mouseout': handler2, ... }
            // handlerOrOptions is the options for all events
            const eventOptions = handlerOrOptions !== undefined ? handlerOrOptions : {passive: true};

            Object.entries(eventOrEvents).forEach(([event, eventHandler]) => {
                doc.addEventListener(event, eventHandler, eventOptions);
                listeners.push({event, handler: eventHandler, options: eventOptions});
            });
        }
        // Handle single event case
        else if (typeof eventOrEvents === 'string' && typeof handlerOrOptions === 'function') {
            doc.addEventListener(eventOrEvents, handlerOrOptions, options);
            listeners.push({event: eventOrEvents, handler: handlerOrOptions, options});
        } else {
            console.error('Jex.onDocument: Invalid parameters');
            return () => {
            }; // Return no-op function
        }

        // Return cleanup function
        return () => {
            listeners.forEach(({event, handler, options}) => {
                doc.removeEventListener(event, handler, options);
            });
        };
    }

    /**
     * Add event listener(s) to the window
     * @param {string|Object} eventOrEvents - Event name or object with event:handler pairs
     * @param {Function|boolean|Object} handlerOrOptions - Handler function (if first param is string) or options (if first param is object)
     * @param {boolean|Object} [options={ passive: true }] - Event options (only if first param is string)
     * @returns {Function} Cleanup function to remove all added listeners
     */
    onWindow(eventOrEvents, handlerOrOptions, options = {passive: true}) {
        const win = this.#doc?.defaultView || window;
        const listeners = [];

        // Handle multiple events case
        if (typeof eventOrEvents === 'object' && eventOrEvents !== null) {
            const eventOptions = handlerOrOptions !== undefined ? handlerOrOptions : {passive: true};

            Object.entries(eventOrEvents).forEach(([event, eventHandler]) => {
                win.addEventListener(event, eventHandler, eventOptions);
                listeners.push({event, handler: eventHandler, options: eventOptions});
            });
        }
        // Handle single event case
        else if (typeof eventOrEvents === 'string' && typeof handlerOrOptions === 'function') {
            win.addEventListener(eventOrEvents, handlerOrOptions, options);
            listeners.push({event: eventOrEvents, handler: handlerOrOptions, options});
        } else {
            console.error('Jex.onWindow: Invalid parameters');
            return () => {
            }; // Return no-op function
        }

        // Return cleanup function
        return () => {
            listeners.forEach(({event, handler, options}) => {
                win.removeEventListener(event, handler, options);
            });
        };
    }

    /**
     * Add global keydown listener with key combo string (e.g., "Ctrl+K")
     * @param {string} combo - Key combination string (e.g., "Ctrl+Shift+X")
     * @param {Function} handler - Callback function
     * @param {Object} [options={}] - Event listener options
     * @returns {Function} Cleanup function to remove the listener
     */
    onKey(combo, handler, options = {passive: true}) {
        const keys = combo.toLowerCase().split('+').map(k => k.trim());

        const listener = (e) => {
            const pressed = [
                e.ctrlKey ? 'ctrl' : null,
                e.metaKey ? 'meta' : null,
                e.altKey ? 'alt' : null,
                e.shiftKey ? 'shift' : null,
                e.key.toLowerCase()
            ].filter(Boolean);

            if (keys.every(k => pressed.includes(k))) {
                handler(e);
            }
        };

        window.addEventListener('keydown', listener, options);

        return () => window.removeEventListener('keydown', listener, options);
    }
}

// Global jex instance
export const jex = new Jex();



================================================================================
FILE: JexInspector.js
Type: JS
Size: 17.51 KB
Last Modified: 2025-09-12T07:51:29.465Z
Lines: 526
MD5: 0b0b5f443343042ec7c41edd5225dccf
================================================================================

/**
 * JexInspector.js - Visual element inspection tool for Jex ecosystem
 *
 * CLASS STRUCTURE:
 * ---------------
 * Public Fields:
 *   - isEnabled {boolean}: Whether inspector mode is active
 *   - options {Object}: Configuration options (toggleKey, enabled, showTooltip)
 *
 * Private Fields:
 *   - #container {Jex}: Parent container for all overlay elements
 *   - #overlays {Object}: DOM overlay element references
 *   - #tooltip {Jex}: Tooltip element reference
 *   - #hoveredElement {Element}: Currently inspected element
 *   - #eventCleanup {Object}: Event cleanup functions
 *
 * Public Methods:
 *   - enable(): void - Enable inspector mode
 *   - disable(): void - Disable inspector mode
 *   - toggle(): void - Toggle inspector mode
 *   - setEnabled(enabled: boolean): void - Enable/disable keyboard shortcuts
 *   - setToggleKey(key: string): void - Set the toggle key
 *   - destroy(): void - Clean up all resources
 *
 * Dependencies:
 *   - Jex: For DOM manipulation and event handling
 *   - JexLogger: For console integration (logger)
 *
 * Relations:
 *   - Part of: Jex ecosystem
 *   - Used by: Jex-based applications
 *   - Uses: jex from Jex.js, logger from JexLogger.js
 *
 * Last Modified: 2025-01-13 - Fixed highlighting issues and updated IDs
 */

import { jex } from './Jex.js';
import { logger } from './JexLogger.js';

// Version constant
export const INSPECTOR_VERSION = '2025.01.13';

export class JexInspector {
    // Private fields
    #container = null;
    #overlays = {};
    #tooltip = null;
    #hoveredElement = null;
    #eventCleanup = {};

    constructor(options = {}) {
        // Inspector state
        this.isEnabled = false;

        // Configuration options
        this.options = {
            toggleKey: 'F2',
            enabled: true,
            showTooltip: true,
            ...options
        };

        this.#init();
    }

    #init() {
        this.#injectStyles();
        this.#createContainer();
        this.#createOverlays();

        if (this.options.showTooltip) {
            this.#createTooltip();
        }

        // Listen to logger console events
        this.#eventCleanup.console = jex.onWindow({
            'jex:console:show': () => this.enable(),
            'jex:console:hide': () => this.disable()
        });

        // Setup keyboard shortcuts
        if (this.options.enabled) {
            this.#setupKeyboard();
        }
    }

    #injectStyles() {
        jex.injectStyles('jexInspectorStyles', `
            /* Static stripes for margins */
            .jex-inspector-stripes {
                background-image: repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(59, 130, 246, 0.1) 10px,
                    rgba(59, 130, 246, 0.1) 20px
                );
            }
            
            /* Animated stripes for element background */
            .jex-inspector-stripes-animated {
                background-image: repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(59, 130, 246, 0.15) 10px,
                    rgba(59, 130, 246, 0.15) 20px
                );
                background-size: 28.28px 28.28px;
                animation: jex-inspector-move 1s linear infinite;
            }
            
            @keyframes jex-inspector-move {
                0% { background-position: 0 0; }
                100% { background-position: 28.28px 0; }
            }
        `);
    }

    #createContainer() {
        this.#container = jex.create('div', 'jexInspectorContainer')
            .cls('fixed inset-0 pointer-events-none z-[9995] hidden')
            .mountToBody();
    }

    #createOverlays() {
        const baseClasses = 'absolute pointer-events-none transition-opacity duration-150';

        // Margin overlays with stripes
        const marginClasses = `${baseClasses} bg-blue-400/10 border border-blue-400/50 jex-inspector-stripes`;

        this.#overlays.marginTop = this.#container.add('div', 'jexInspectorMarginTop')
            .cls(marginClasses);
        this.#overlays.marginRight = this.#container.add('div', 'jexInspectorMarginRight')
            .cls(marginClasses);
        this.#overlays.marginBottom = this.#container.add('div', 'jexInspectorMarginBottom')
            .cls(marginClasses);
        this.#overlays.marginLeft = this.#container.add('div', 'jexInspectorMarginLeft')
            .cls(marginClasses);

        // Element background with animated stripes
        this.#overlays.elementBg = this.#container.add('div', 'jexInspectorElementBg')
            .cls(`${baseClasses} bg-blue-400/20 jex-inspector-stripes-animated`);

        // Border indicator with glow
        this.#overlays.border = this.#container.add('div', 'jexInspectorBorder')
            .cls(`${baseClasses} border-2 border-blue-600 shadow-[0_0_20px_rgba(59,130,246,0.8),0_0_40px_rgba(59,130,246,0.4)]`);

        // Content box
        this.#overlays.content = this.#container.add('div', 'jexInspectorContent')
            .cls(`${baseClasses} border border-blue-500 shadow-[inset_0_0_10px_rgba(59,130,246,0.3)]`);
    }

    #createTooltip() {
        this.#tooltip = jex.create('div', 'jexInspectorTooltip')
            .cls('fixed pointer-events-none hidden z-[10001] px-3 py-2 rounded-md text-xs ' +
                'bg-black/90 border border-blue-500/50 shadow-xl shadow-blue-500/20 font-mono ' +
                'backdrop-blur-sm')
            .mountToBody();
    }

    enable() {
        if (this.isEnabled) return;
        this.isEnabled = true;

        // Show container
        this.#container?.cls('-hidden');

        // Attach mouse events with capture phase for better detection
        this.#eventCleanup.document = jex.onDocument({
            'mouseover': (e) => this.#onMouseOver(e),
            'mousemove': (e) => this.#onMouseMove(e),
            'mouseout': (e) => this.#onMouseOut(e)
        }, true); // capture phase = true

        // Window scroll event
        this.#eventCleanup.window = jex.onWindow('scroll', () => this.#onScroll(), true);
    }

    disable() {
        if (!this.isEnabled) return;
        this.isEnabled = false;

        // Clean up events
        this.#eventCleanup.document?.();
        this.#eventCleanup.window?.();
        this.#eventCleanup.document = null;
        this.#eventCleanup.window = null;

        // Hide container and tooltip
        this.#container?.cls('+hidden');
        this.#tooltip?.cls('+hidden');
        this.#hideOverlays();
    }

    toggle() {
        this.isEnabled ? this.disable() : this.enable();
    }

    #onMouseOver(e) {
        if (!this.isEnabled) return;

        const target = e.target;

        // Skip inspector elements and logger console
        if (!target ||
            target.id?.startsWith('jexInspector') ||
            target.closest('#jexLoggerConsole') ||
            target.closest('#jexInspectorContainer')) {
            return;
        }

        this.#hoveredElement = target;
        this.#showInspection(target);
    }

    #onMouseMove(e) {
        if (!this.isEnabled || !this.options.showTooltip) return;

        // Update tooltip position
        if (this.#tooltip && !this.#tooltip.cls('?hidden')) {
            this.#positionTooltip(e.clientX, e.clientY);
        }
    }

    #onMouseOut(e) {
        if (!this.isEnabled) return;

        // Check if we're leaving the hovered element
        if (e.target === this.#hoveredElement) {
            this.#hoveredElement = null;
            this.#hideOverlays();
        }
    }

    #onScroll() {
        if (!this.isEnabled || !this.#hoveredElement) return;

        // Check if element is still in the DOM
        if (!this.#hoveredElement.isConnected) {
            this.#hoveredElement = null;
            this.#hideOverlays();
            return;
        }

        // Update overlay positions
        this.#showInspection(this.#hoveredElement);
    }

    #showInspection(element) {
        const rect = element.getBoundingClientRect();
        const computed = window.getComputedStyle(element);

        // Get box model values
        const margin = {
            top: parseFloat(computed.marginTop) || 0,
            right: parseFloat(computed.marginRight) || 0,
            bottom: parseFloat(computed.marginBottom) || 0,
            left: parseFloat(computed.marginLeft) || 0
        };

        const border = {
            top: parseFloat(computed.borderTopWidth) || 0,
            right: parseFloat(computed.borderRightWidth) || 0,
            bottom: parseFloat(computed.borderBottomWidth) || 0,
            left: parseFloat(computed.borderLeftWidth) || 0
        };

        const padding = {
            top: parseFloat(computed.paddingTop) || 0,
            right: parseFloat(computed.paddingRight) || 0,
            bottom: parseFloat(computed.paddingBottom) || 0,
            left: parseFloat(computed.paddingLeft) || 0
        };

        // Make all elements visible
        this.#showAllOverlays();

        // Position margin indicators
        this.#positionMargins(rect, margin);

        // Position element background with animated stripes
        this.#overlays.elementBg.style({
            left: `${rect.left}px`,
            top: `${rect.top}px`,
            width: `${rect.width}px`,
            height: `${rect.height}px`
        });

        // Position border box (2px border, so offset by -2)
        this.#overlays.border.style({
            left: `${rect.left - 2}px`,
            top: `${rect.top - 2}px`,
            width: `${rect.width}px`,
            height: `${rect.height}px`
        });

        // Position content box
        const contentWidth = rect.width - border.left - border.right - padding.left - padding.right;
        const contentHeight = rect.height - border.top - border.bottom - padding.top - padding.bottom;

        if (contentWidth > 0 && contentHeight > 0) {
            this.#overlays.content.style({
                left: `${rect.left + border.left + padding.left - 1}px`,
                top: `${rect.top + border.top + padding.top - 1}px`,
                width: `${contentWidth}px`,
                height: `${contentHeight}px`,
                opacity: '1'
            });
        } else {
            this.#overlays.content.style({ opacity: '0' });
        }

        // Update tooltip
        if (this.options.showTooltip && this.#tooltip) {
            this.#updateTooltip(element, margin, border, padding);
        }
    }

    #showAllOverlays() {
        // Show all overlays by setting opacity to 1
        Object.values(this.#overlays).forEach(overlay => {
            overlay.style({ opacity: '1' });
        });
    }

    #hideOverlays() {
        // Hide all overlays by setting opacity to 0
        Object.values(this.#overlays).forEach(overlay => {
            overlay.style({ opacity: '0' });
        });
        this.#tooltip?.cls('+hidden');
    }

    #positionMargins(rect, margin) {
        // Helper function to show/hide and position margin elements
        const setMargin = (overlay, show, styles) => {
            if (show && styles) {
                overlay.style({
                    ...this.#pxStyles(styles),
                    opacity: '1'
                });
            } else {
                overlay.style({ opacity: '0' });
            }
        };

        // Top margin
        setMargin(this.#overlays.marginTop, margin.top > 0, {
            left: rect.left - margin.left - 1,
            top: rect.top - margin.top - 1,
            width: rect.width + margin.left + margin.right,
            height: margin.top - 1
        });

        // Right margin
        setMargin(this.#overlays.marginRight, margin.right > 0, {
            left: rect.left + rect.width,
            top: rect.top - 1,
            width: margin.right - 1,
            height: rect.height
        });

        // Bottom margin
        setMargin(this.#overlays.marginBottom, margin.bottom > 0, {
            left: rect.left - margin.left - 1,
            top: rect.top + rect.height,
            width: rect.width + margin.left + margin.right,
            height: margin.bottom - 1
        });

        // Left margin
        setMargin(this.#overlays.marginLeft, margin.left > 0, {
            left: rect.left - margin.left - 1,
            top: rect.top - 1,
            width: margin.left - 1,
            height: rect.height
        });
    }

    #pxStyles(styles) {
        const result = {};
        Object.entries(styles).forEach(([key, value]) => {
            result[key] = `${value}px`;
        });
        return result;
    }

    #updateTooltip(element, margin, border, padding) {
        const tag = element.tagName.toLowerCase();
        const id = element.id ? `#${element.id}` : '';
        const classes = element.className ?
            `.${element.className.trim().split(/\s+/).filter(c => c && !c.startsWith('hover:')).slice(0, 3).join('.')}` : '';

        const rect = element.getBoundingClientRect();

        // Clear and rebuild tooltip content
        this.#tooltip.clear();

        // Element info section
        const elementInfo = this.#tooltip.add('div').cls('flex items-center gap-2');
        elementInfo.add('span').cls('text-blue-300 font-bold').text(`<${tag}>`);
        if (id) elementInfo.add('span').cls('text-white').text(id);
        if (classes) elementInfo.add('span').cls('text-gray-400 text-[10px]').text(classes);

        // Dimensions
        this.#tooltip.add('div')
            .cls('mt-1 text-white font-medium')
            .text(`${Math.round(rect.width)} × ${Math.round(rect.height)} px`);

        // Position info
        this.#tooltip.add('div')
            .cls('text-gray-500 text-[10px]')
            .text(`(${Math.round(rect.left)}, ${Math.round(rect.top)})`);

        // Box model info if any values exist
        const hasBoxModel = margin.top || margin.right || margin.bottom || margin.left ||
            border.top || border.right || border.bottom || border.left ||
            padding.top || padding.right || padding.bottom || padding.left;

        if (hasBoxModel) {
            const boxModel = this.#tooltip.add('div')
                .cls('mt-2 pt-2 border-t border-gray-700 space-y-0.5');

            // Helper to format box values
            const addBoxInfo = (label, values, labelColor, valueColor) => {
                const hasValues = values.top || values.right || values.bottom || values.left;
                if (hasValues) {
                    const div = boxModel.add('div').cls('flex items-center gap-2');
                    div.add('span').cls(`${labelColor} font-bold w-4`).text(label);
                    div.add('span').cls(`${valueColor} text-[11px] font-mono`)
                        .text(`${values.top} ${values.right} ${values.bottom} ${values.left}`);
                }
            };

            // Use light blue for all box model labels
            addBoxInfo('M', margin, 'text-blue-300', 'text-gray-300');
            addBoxInfo('B', border, 'text-blue-300', 'text-gray-300');
            addBoxInfo('P', padding, 'text-blue-300', 'text-gray-300');
        }

        this.#tooltip.cls('-hidden');
    }

    #positionTooltip(mouseX, mouseY) {
        if (!this.#tooltip) return;

        const tooltip = this.#tooltip.ref;
        const tooltipRect = tooltip.getBoundingClientRect();

        let left = mouseX + 15;
        let top = mouseY + 15;

        // Adjust if tooltip would go off screen
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = mouseX - tooltipRect.width - 15;
        }

        if (top + tooltipRect.height > window.innerHeight - 10) {
            top = mouseY - tooltipRect.height - 15;
        }

        this.#tooltip.style({
            left: `${left}px`,
            top: `${top}px`
        });
    }

    #setupKeyboard() {
        // Clean up any existing handler first
        this.#eventCleanup.keyboard = jex.onDocument('keydown',
            (e) => this.#handleKeyboard(e),
            { passive: false }
        );
    }

    #handleKeyboard(e) {
        if (e.key === this.options.toggleKey) {
            e.preventDefault();
            logger.toggleConsole();
        }
    }

    setEnabled(enabled) {
        this.options.enabled = enabled;
        if (enabled) {
            this.#setupKeyboard();
        } else {
            // Clean up keyboard handler
            this.#eventCleanup.keyboard?.();
            this.#eventCleanup.keyboard = null;
        }
    }

    setToggleKey(key) {
        this.options.toggleKey = key;
    }

    destroy() {
        // Disable first
        this.disable();

        // Remove container (which removes all child elements)
        this.#container?.remove();

        // Remove tooltip separately
        this.#tooltip?.remove();

        // Clean up keyboard shortcuts
        this.#eventCleanup.keyboard?.();
        this.#eventCleanup.console?.();

        // Remove pattern styles
        jex.remove('jexInspectorStyles');

        // Clear references
        this.#hoveredElement = null;
        this.#container = null;
        this.#overlays = {};
        this.#tooltip = null;
        this.#eventCleanup = {};
    }
}

// Create global instance
export const inspector = new JexInspector();


================================================================================
FILE: JexLogger.js
Type: JS
Size: 24.11 KB
Last Modified: 2025-09-12T07:20:42.795Z
Lines: 704
MD5: 68f726e29231ded429bec1d4977a849a
================================================================================

/**
 * JexLogger.js - Console and logging system for Jex ecosystem
 *
 * CLASS STRUCTURE:
 * ---------------
 * Public Fields:
 *   - logLevels {Object}: Numeric mapping for log filtering
 *   - currentLogLevel {string}: Current active log level
 *
 * Private Fields:
 *   - #config {Object}: Configuration for levels and defaults
 *   - #state {Object}: Console state (messages, visibility, etc.)
 *   - #dom {Object}: DOM element references
 *   - #messageIndex {number}: Global message counter
 *   - #tooltipTimeout {number}: Tooltip hide timeout
 *
 * Public Methods:
 *   - toggleConsole(): void - Toggle console visibility
 *   - updateDisplayedMessages(): void - Update displayed messages based on filter
 *   - clearConsole(): void - Clear all console messages
 *   - destroy(): void - Clean up and restore original console methods
 *   - info/debug/warn/error/trace(...args): void - Logging methods
 *
 * Dependencies:
 *   - Jex: For DOM manipulation and event handling
 *
 * Relations:
 *   - Part of: Jex ecosystem
 *   - Used by: All Jex-based applications
 *   - Uses: jex from Jex.js
 *
 * Last Modified: 2025-01-13 - Refactored as JexLogger with DRY improvements
 */

import { jex } from './Jex.js';

// Version constant
export const LOGGER_VERSION = '2025.01.13';

export class JexLogger {
    // Private fields
    #config = {
        levels: {
            trace: { color: 'purple', text: 'text-purple-400', bg: 'bg-purple-500/10', border: 'border-l-purple-500', hover: 'hover:bg-purple-500/20', indicator: 'bg-purple-500' },
            debug: { color: 'blue', text: 'text-blue-300', bg: 'bg-blue-400/10', border: 'border-l-blue-400', hover: 'hover:bg-blue-400/20', indicator: 'bg-blue-400' },
            info: { color: 'green', text: 'text-green-500', bg: 'bg-green-600/10', border: 'border-l-green-600', hover: 'hover:bg-green-600/20', indicator: 'bg-green-600' },
            warn: { color: 'yellow', text: 'text-yellow-400', bg: 'bg-yellow-500/10', border: 'border-l-yellow-500', hover: 'hover:bg-yellow-500/20', indicator: 'bg-yellow-500' },
            error: { color: 'red', text: 'text-red-400', bg: 'bg-red-500/10', border: 'border-l-red-500', hover: 'hover:bg-red-500/20', indicator: 'bg-red-500' }
        },
        defaults: {
            maxLogs: 1000,
            height: '30vh',
            maxHeight: window.innerHeight * 0.8,
            animationDuration: 300
        }
    };

    #state = {
        messages: [],
        isVisible: false,
        isAnimating: false,
        isMinimized: false,
        lastHeight: null,
        lastMessage: null,
        originals: {}
    };

    #dom = {};
    #messageIndex = 0;
    #tooltipTimeout = null;

    // Public fields
    logLevels = { trace: 0, debug: 1, info: 2, warn: 3, error: 4 };
    currentLogLevel = 'debug';

    constructor() {
        this.#init();
    }

    #init() {
        this.#injectStyles();
        this.#createUI();
        this.#createFiller();
        this.#interceptConsole();
        this.#showWelcome();
    }

    #injectStyles() {
        jex.injectStyles('jexLoggerStyles', `
            #jexLoggerOutput::-webkit-scrollbar {
                width: 8px;
            }
            #jexLoggerOutput::-webkit-scrollbar-track {
                background: rgba(31, 41, 55, 0.5);
                border-radius: 4px;
            }
            #jexLoggerOutput::-webkit-scrollbar-thumb {
                background-color: rgba(107, 114, 128, 0.5);
                border-radius: 4px;
            }
            #jexLoggerOutput::-webkit-scrollbar-thumb:hover {
                background-color: rgba(156, 163, 175, 0.5);
            }
            
            .jex-logger-tooltip {
                position: fixed;
                z-index: 10001;
                background: rgba(0, 0, 0, 0.95);
                border: 1px solid rgba(59, 130, 246, 0.5);
                border-radius: 4px;
                padding: 12px;
                font-size: 11px;
                font-family: monospace;
                color: #e5e7eb;
                white-space: pre;
                max-width: 600px;
                max-height: 300px;
                overflow: auto;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            }
            
            .jex-logger-tooltip.visible {
                opacity: 1;
                pointer-events: auto;
            }
        `);
    }

    #createUI() {
        // Main console container
        this.#dom.root = jex.create('div', 'jexLoggerConsole')
            .cls('fixed inset-x-0 bottom-0 bg-gray-900 z-[10000] hidden transform translate-y-full ' +
                'transition-transform duration-300 ease-out font-mono shadow-[0_-4px_20px_rgba(0,0,0,0.3)]')
            .style({ height: this.#config.defaults.height })
            .mountToBody();

        this.#createHeader();
        this.#createOutput();
        this.#createTooltip();
        this.#setupResize();

        // Handle transition end
        this.#dom.root.on('transitionend', () => {
            if (!this.#state.isVisible) {
                this.#dom.root.cls('+hidden');
            }
            this.#state.isAnimating = false;
        });
    }

    #createHeader() {
        const header = this.#dom.root.add('div', 'jexLoggerHeader')
            .cls('flex items-center justify-between px-3 py-1.5 bg-gray-800 border-b border-gray-700 cursor-ns-resize h-8');

        // Left section
        const left = header.add('div').cls('flex items-center gap-4');

        this.#dom.title = left.add('span')
            .cls('text-gray-300 text-sm font-medium cursor-pointer hover:text-gray-100 transition-colors select-none')
            .text('Debug Console')
            .attr('title', 'Click to clear console')
            .onClick(() => this.clearConsole());

        this.#dom.messageCount = left.add('span')
            .cls('text-gray-500 text-xs')
            .text('0 messages');

        // Right section
        const right = header.add('div').cls('flex items-center gap-3');
        this.#createLevelSelector(right);
        this.#createCloseButton(right);
    }

    #createLevelSelector(parent) {
        this.#dom.levelIndicator = parent.add('div')
            .cls('flex items-center gap-1.5 px-3 py-1 bg-gray-700 rounded text-xs cursor-pointer ' +
                'hover:bg-gray-600 transition-all duration-200 select-none')
            .attr('title', 'Click to change log level')
            .onClick(() => this.#cycleLogLevel());

        this.#dom.levelSquare = this.#dom.levelIndicator.add('span')
            .cls(`inline-block w-3 h-3 rounded-sm ${this.#config.levels[this.currentLogLevel].indicator}`);

        this.#dom.levelText = this.#dom.levelIndicator.add('span')
            .cls('text-gray-300 font-medium uppercase tracking-wider')
            .text(this.currentLogLevel);

        this.#dom.levelIndicator.add('span')
            .cls('text-gray-500')
            .html('<i class="fas fa-chevron-down text-[10px]"></i>');
    }

    #createCloseButton(parent) {
        parent.add('button')
            .cls('text-gray-400 px-2 text-sm opacity-80 hover:opacity-100 hover:text-gray-200 ' +
                'transition-all bg-transparent border-0 cursor-pointer')
            .html('✕')
            .attr('title', 'Close Console (F2)')
            .onClick(() => this.toggleConsole());
    }

    #createOutput() {
        this.#dom.output = this.#dom.root.add('div', 'jexLoggerOutput')
            .cls('p-3 overflow-y-auto bg-black text-gray-300')
            .style({ height: 'calc(100% - 32px)' });
    }

    #createTooltip() {
        this.#dom.tooltip = jex.create('div', 'jexLoggerTooltip')
            .cls('jex-logger-tooltip')
            .mountToBody();
    }

    #createFiller() {
        this.#dom.filler = jex.create('div', 'jexLoggerFiller')
            .cls('w-full block transition-[height] duration-300 ease-out')
            .style({ height: '0px' })
            .mountToBody();
    }

    #setupResize() {
        this.#dom.root.select('#jexLoggerHeader').on('mousedown', (e) => {
            const startY = e.clientY;
            const startHeight = parseInt(getComputedStyle(this.#dom.root.ref).height);

            const resize = (e) => {
                const delta = startY - e.clientY;
                const newHeight = Math.min(Math.max(startHeight + delta, 32), this.#config.defaults.maxHeight);
                this.#dom.root.style({ height: `${newHeight}px` });
                this.#dom.filler.style({ height: `${newHeight}px` });
            };

            const stopResize = () => {
                cleanupMove();
                cleanupUp();

                const finalHeight = parseInt(getComputedStyle(this.#dom.root.ref).height);

                if (finalHeight <= 50) {
                    this.#dom.root.style({ height: '32px' });
                    this.#dom.filler.style({ height: '32px' });
                    this.#dom.output.cls('+hidden');
                    this.#state.isMinimized = true;
                } else {
                    this.#state.lastHeight = `${finalHeight}px`;
                    this.#dom.output.cls('-hidden');
                    this.#state.isMinimized = false;
                }
            };

            const cleanupMove = jex.onDocument('mousemove', resize);
            const cleanupUp = jex.onDocument('mouseup', stopResize);
            e.preventDefault();
        });
    }

    #cycleLogLevel() {
        const levels = Object.keys(this.#config.levels);
        const currentIndex = levels.indexOf(this.currentLogLevel);
        const nextIndex = (currentIndex + 1) % levels.length;

        this.currentLogLevel = levels[nextIndex];
        this.#updateLevelIndicator();
        this.updateDisplayedMessages();
    }

    #updateLevelIndicator() {
        this.#dom.levelText?.text(this.currentLogLevel);

        if (this.#dom.levelSquare) {
            // Remove old indicator class and add new one
            Object.values(this.#config.levels).forEach(config => {
                this.#dom.levelSquare.cls(`-${config.indicator}`);
            });
            this.#dom.levelSquare.cls(`+${this.#config.levels[this.currentLogLevel].indicator}`);
        }
    }

    #interceptConsole() {
        Object.keys(this.#config.levels).forEach(level => {
            this.#state.originals[level] = console[level] || console.log;

            console[level] = (...args) => {
                this.#state.originals[level].apply(console, args);

                const messageData = level === 'trace'
                    ? this.#formatTraceMessage(level, ...args)
                    : this.#formatLogMessage(level, ...args);

                this.#addMessage({
                    level,
                    text: messageData.formatted,
                    index: messageData.index,
                    caller: messageData.caller,
                    stacktrace: messageData.stacktrace,
                    timestamp: Date.now(),
                    count: 1
                });
            };
        });
    }

    #formatLogMessage(level, ...args) {
        const time = new Date().toLocaleTimeString('en-US', {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            fractionalSecondDigits: 3
        });

        const caller = this.#getCaller();
        const stacktrace = this.#getStacktrace();

        const formattedArgs = args.map(arg => {
            if (typeof arg === 'object') {
                try {
                    return JSON.stringify(arg, null, 2);
                } catch (e) {
                    return String(arg);
                }
            }
            return String(arg);
        }).join(' ');

        this.#messageIndex++;

        const parts = [
            level.toUpperCase().padEnd(5),
            `#${this.#messageIndex}`,
            `[${time}]`
        ];

        if (caller && caller !== 'unknown') {
            parts.push(`<${caller}>`);
        }

        parts.push('\n' + formattedArgs);

        return {
            formatted: parts.join(' '),
            index: this.#messageIndex,
            caller,
            stacktrace
        };
    }

    #formatTraceMessage(level, ...args) {
        const baseData = this.#formatLogMessage(level, ...args);
        const stack = this.#getEnhancedStacktrace();

        return {
            ...baseData,
            formatted: `${baseData.formatted}\n${stack}`
        };
    }

    #getCaller() {
        const stack = new Error().stack;
        const lines = stack.split('\n');

        for (let i = 4; i < lines.length; i++) {
            const line = lines[i];

            if (line.includes('JexLogger') ||
                line.includes('console.') ||
                line.includes('Object.') ||
                line.includes('Function.')) {
                continue;
            }

            const match = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/) ||
                line.match(/at\s+(.+?):(\d+):(\d+)/);

            if (match) {
                const fileName = (match[2] || match[1]).split('/').pop();
                const lineNum = match[3] || match[2];
                return `${fileName}:${lineNum}`;
            }
        }

        return 'unknown';
    }

    #getStacktrace() {
        const stack = new Error().stack;
        const lines = stack.split('\n').slice(5);

        return lines
            .filter(line => line.trim() &&
                !line.includes('JexLogger') &&
                !line.includes('console.') &&
                !line.includes('Object.<anonymous>'))
            .map(line => this.#cleanStackLine(line))
            .join('\n');
    }

    #getEnhancedStacktrace() {
        const stack = new Error().stack;
        const lines = stack.split('\n').slice(5);

        return lines
            .filter(line => line.trim() &&
                !line.includes('JexLogger') &&
                !line.includes('console.trace'))
            .map(line => {
                const trimmed = line.trim();
                const match = trimmed.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/) ||
                    trimmed.match(/at\s+(.+?):(\d+):(\d+)/);

                if (match) {
                    const method = match[1] || 'anonymous';
                    const fileName = (match[2] || match[1]).split('/').pop();
                    const lineNum = match[3] || match[2];
                    const colNum = match[4] || match[3];
                    return `  → ${method} (${fileName}:${lineNum}:${colNum})`;
                }

                return `  ${trimmed}`;
            })
            .join('\n');
    }

    #cleanStackLine(line) {
        const match = line.match(/at\s+(.+?)\s+\((.+):(\d+):(\d+)\)/) ||
            line.match(/at\s+(.+):(\d+):(\d+)/);

        if (match) {
            const funcName = match[1] || 'anonymous';
            const fullPath = match[2] || match[1];
            const lineNum = match[3] || match[2];
            const colNum = match[4] || match[3];
            const cleanPath = fullPath.replace(/^https?:\/\/[^\/]+\//, '');

            return funcName !== 'anonymous'
                ? `at ${funcName} (${cleanPath}:${lineNum}:${colNum})`
                : `at ${cleanPath}:${lineNum}:${colNum}`;
        }

        return line;
    }

    #addMessage(message) {
        // Group similar messages
        const lastMsg = this.#state.messages[this.#state.messages.length - 1];

        if (lastMsg &&
            lastMsg.text === message.text &&
            lastMsg.level === message.level &&
            lastMsg.caller === message.caller) {
            lastMsg.count++;
            lastMsg.timestamp = Date.now();

            if (this.#state.isVisible) {
                this.updateDisplayedMessages();
            }
            return;
        }

        this.#state.messages.push(message);
        this.#state.lastMessage = message;

        if (this.#state.messages.length > this.#config.defaults.maxLogs) {
            this.#state.messages.shift();
        }

        if (this.#state.isVisible) {
            this.updateDisplayedMessages();
        }
    }

    updateDisplayedMessages() {
        const filtered = this.#state.messages.filter(
            m => this.logLevels[m.level] >= this.logLevels[this.currentLogLevel]
        );

        // Update message count
        if (this.#dom.messageCount) {
            const total = this.#state.messages.length;
            const shown = filtered.length;
            const text = total === shown ? `${total} messages` : `${shown} of ${total} messages`;
            this.#dom.messageCount.text(text);
        }

        // Clear and rebuild output
        this.#dom.output.clear();

        filtered.forEach((msg, idx) => {
            this.#renderMessage(msg, idx);
        });

        // Scroll to bottom
        this.#dom.output.ref.scrollTop = this.#dom.output.ref.scrollHeight;
    }

    #renderMessage(msg, idx) {
        const levelConfig = this.#config.levels[msg.level];

        const entry = this.#dom.output.add('div', `jexLoggerMessage${idx}`)
            .cls(`my-0.5 px-2.5 py-1.5 rounded border-l-[3px] relative transition-all duration-200 text-xs cursor-pointer ` +
                `${levelConfig.bg} ${levelConfig.border} ${levelConfig.text} ${levelConfig.hover}`)
            .attr('data-stacktrace', msg.stacktrace || '');

        // Add stacktrace hover
        if (msg.stacktrace) {
            entry.on('mouseenter', (e) => this.#showTooltip(e, msg.stacktrace));
            entry.on('mouseleave', () => this.#hideTooltip());
            entry.on('mousemove', (e) => this.#updateTooltipPosition(e));
        }

        // Count badge
        if (msg.count > 1) {
            entry.add('span')
                .cls('absolute right-2.5 top-1.5 bg-white/20 text-white px-1.5 py-0.5 rounded-full text-[10px] font-bold')
                .text(`×${msg.count}`);
        }

        this.#renderMessageContent(entry, msg, idx);
    }

    #renderMessageContent(entry, msg, idx) {
        const lines = msg.text.split('\n');
        const headerLine = lines[0];
        const messageLine = lines.slice(1).join('\n');

        // Parse header
        const headerMatch = headerLine.match(/^(\w+)\s+(#\d+)\s+\[(.*?)\](?:\s+<(.*?)>)?/);
        if (headerMatch) {
            const [, level, index, time, caller] = headerMatch;

            const header = entry.add('div').cls('flex items-center gap-2 flex-wrap');
            header.add('span').cls('font-bold uppercase').text(level);

            if (index) header.add('span').cls('text-gray-400 text-[11px]').text(index);
            if (time) header.add('span').cls('text-gray-400 text-[11px]').text(`[${time}]`);
            if (caller && caller !== 'unknown') {
                header.add('span').cls('text-gray-500 text-[11px] italic').text(`<${caller}>`);
            }

            if (msg.stacktrace) {
                header.add('span')
                    .cls('text-gray-400 text-[10px] ml-1')
                    .attr('title', 'Hover to see stacktrace')
                    .html('<i class="fas fa-layer-group"></i>');
            }
        }

        // Message content
        if (messageLine) {
            const msgDiv = entry.add('div').cls('mt-1 whitespace-pre-wrap break-words');

            if (this.#isJSON(messageLine)) {
                this.#renderJSON(msgDiv, messageLine);
            } else {
                msgDiv.text(messageLine);
            }
        }
    }

    #isJSON(str) {
        const trimmed = str.trim();
        return (trimmed.startsWith('{') && trimmed.endsWith('}')) ||
            (trimmed.startsWith('[') && trimmed.endsWith(']'));
    }

    #renderJSON(container, jsonStr) {
        try {
            const obj = JSON.parse(jsonStr);
            const formatted = JSON.stringify(obj, null, 2);

            const highlighted = formatted
                .replace(/"([^"]+)":/g, '<span class="text-pink-400">"$1"</span>:')
                .replace(/:\s*"([^"]*)"/g, ': <span class="text-green-400">"$1"</span>')
                .replace(/:\s*(\d+)/g, ': <span class="text-yellow-400">$1</span>')
                .replace(/:\s*(true|false)/g, ': <span class="text-blue-400">$1</span>')
                .replace(/:\s*null/g, ': <span class="text-gray-500">null</span>');

            container.html(highlighted);
        } catch (e) {
            container.text(jsonStr);
        }
    }

    #showTooltip(event, stacktrace) {
        clearTimeout(this.#tooltipTimeout);

        this.#dom.tooltip.text(stacktrace);
        this.#dom.tooltip.style({ visibility: 'visible', opacity: '0' });

        this.#updateTooltipPosition(event);

        requestAnimationFrame(() => {
            this.#dom.tooltip.cls('+visible');
        });
    }

    #updateTooltipPosition(event) {
        const tooltip = this.#dom.tooltip;
        const rect = tooltip.ref.getBoundingClientRect();

        let left = event.clientX + 15;
        let top = event.clientY - rect.height - 10;

        if (left + rect.width > window.innerWidth - 10) {
            left = event.clientX - rect.width - 15;
        }

        if (top < 10) {
            top = event.clientY + 15;
        }

        tooltip.style({
            left: `${left}px`,
            top: `${top}px`
        });
    }

    #hideTooltip() {
        this.#tooltipTimeout = setTimeout(() => {
            this.#dom.tooltip.cls('-visible');
            setTimeout(() => {
                this.#dom.tooltip.style({ visibility: 'hidden' });
            }, 200);
        }, 100);
    }

    toggleConsole() {
        if (this.#state.isAnimating) return;

        this.#state.isAnimating = true;
        this.#state.isVisible = !this.#state.isVisible;

        setTimeout(() => {
            this.#state.isAnimating = false;
        }, this.#config.defaults.animationDuration + 50);

        if (this.#state.isVisible) {
            this.#dom.root.cls('-hidden');

            requestAnimationFrame(() => {
                this.#dom.root.cls('-translate-y-full');
                this.#dom.filler.style({
                    height: this.#state.lastHeight || this.#config.defaults.height
                });

                if (this.#state.isMinimized) {
                    this.#dom.output.cls('-hidden');
                }
                this.updateDisplayedMessages();
            });

            window.dispatchEvent(new CustomEvent('jex:console:show'));
        } else {
            this.#dom.root.cls('+translate-y-full');
            this.#dom.filler.style({ height: '0px' });

            window.dispatchEvent(new CustomEvent('jex:console:hide'));
        }
    }

    clearConsole() {
        this.#state.messages = [];
        this.#state.lastMessage = null;
        this.#messageIndex = 0;
        this.#dom.output.clear();
        this.#showWelcome();
    }

    #showWelcome() {
        console.info('Jex Logger v' + LOGGER_VERSION + ' | Press F2 to toggle console');
    }

    destroy() {
        // Restore original console methods
        Object.entries(this.#state.originals).forEach(([method, orig]) => {
            console[method] = orig;
        });

        // Remove DOM elements
        this.#dom.root?.remove();
        this.#dom.filler?.remove();
        this.#dom.tooltip?.remove();

        // Remove styles
        jex.remove('jexLoggerStyles');

        // Clear state
        this.#state.messages = [];
        this.#messageIndex = 0;
    }

    // Convenience logging methods
    info(...args) { console.info(...args); }
    debug(...args) { (console.debug || console.log).apply(console, args); }
    warn(...args) { console.warn(...args); }
    error(...args) { console.error(...args); }
    trace(...args) { console.trace(...args); }
}

// Create and export the logger instance
export const logger = new JexLogger();


================================================================================
FILE: JexToast.js
Type: JS
Size: 16.27 KB
Last Modified: 2025-09-11T19:57:20.452Z
Lines: 538
MD5: 8d09747f99e6354f4899f0177e8c4662
================================================================================

/**
 * JexToast.js - Advanced toast notification component for Jex Framework
 *
 * CLASS STRUCTURE:
 * ---------------
 * Public Fields:
 *   - options {Object}: Configuration options for the toast
 *   - isVisible {boolean}: Whether any toast is currently visible
 *
 * Private Fields:
 *   - #dom {Object}: DOM element references
 *   - #mounted {boolean}: Whether the toast is mounted to DOM
 *   - #queue {Array}: Queue of pending toast messages
 *   - #visibleToasts {number}: Count of visible toasts
 *   - #activeToasts {Map}: Map of active toast elements and their data
 *   - #lastToast {Object}: Reference to last shown toast for duplicate detection
 *
 * Public Methods:
 *   - constructor(options: Object): Creates toast instance
 *   - mount(): JexToast - Mount toast to document body
 *   - show(type: string, message: string, duration?: number): void - Show toast message
 *   - success(message: string, duration?: number): void - Show success toast
 *   - error(message: string, duration?: number): void - Show error toast
 *   - warning(message: string, duration?: number): void - Show warning toast
 *   - info(message: string, duration?: number): void - Show info toast
 *   - command(message: string, duration?: number): void - Show command toast
 *   - check(condition: any, errorMessage: string, callback?: Function): boolean - Check condition and show error if false
 *   - clearAll(): void - Clear all toasts
 *   - destroy(): void - Remove toast from DOM
 *
 * Dependencies:
 *   - Jex: DOM manipulation from Jex Framework
 *   - JexLogger: Logging from Jex Framework
 *
 * Relations:
 *   - Part of: Jex Framework widgets
 *   - Used by: Jex applications
 *   - Uses: jex, logger from Jex Framework
 *
 * Last Modified: 2025-09-11 - Renamed from TopToast to JexToast
 */

// Use CDN imports for Jex framework
import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';
import { logger } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/JexLogger.js';

export class JexToast {
    // Public fields
    options = {};
    isVisible = false;

    // Private fields
    #dom = {};
    #mounted = false;
    #queue = [];
    #visibleToasts = 0;
    #activeToasts = new Map();
    #lastToast = null;

    constructor(options = {}) {
        // Default configuration
        this.options = {
            // Positioning
            position: 'bottom-right', // bottom-right, bottom-left, top-right, top-left
            maxVisible: 3,

            // Behavior
            duration: 5000,
            queueMessages: true,
            detectDuplicates: true,
            showProgress: true,

            // Styling
            maxWidth: 'max-w-md',
            customClass: '',

            // Animation
            animationDuration: 400,

            // Toast types configuration
            types: {
                success: {
                    icon: '✓',
                    bgClass: 'bg-green-600',
                    borderClass: 'border-green-700',
                    textClass: 'text-white',
                    progressClass: 'bg-green-400'
                },
                error: {
                    icon: '✕',
                    bgClass: 'bg-red-500',
                    borderClass: 'border-red-600',
                    textClass: 'text-white',
                    progressClass: 'bg-red-300'
                },
                warning: {
                    icon: '⚠',
                    bgClass: 'bg-amber-500',
                    borderClass: 'border-amber-600',
                    textClass: 'text-white',
                    progressClass: 'bg-amber-300'
                },
                info: {
                    icon: 'ℹ',
                    bgClass: 'bg-blue-500',
                    borderClass: 'border-blue-600',
                    textClass: 'text-white',
                    progressClass: 'bg-blue-300'
                },
                command: {
                    icon: '⌘',
                    bgClass: 'bg-gray-700',
                    borderClass: 'border-gray-600',
                    textClass: 'text-white',
                    progressClass: 'bg-gray-400'
                }
            },

            ...options
        };

        // Initialize toast system
        this.#initToastSystem();
    }

    #initToastSystem() {
        // Inject CSS animations
        this.#injectStyles();

        // Create container
        this.#createContainer();

        logger.debug('JexToast system initialized');
    }

    #injectStyles() {
        jex.injectStyles('jexToastStyles', `
            @keyframes jexToastSlideIn {
                from {
                    transform: translateX(var(--slide-from));
                    opacity: 0;
                    scale: 0.95;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                    scale: 1;
                }
            }
            
            @keyframes jexToastSlideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                    scale: 1;
                }
                to {
                    transform: translateX(var(--slide-to));
                    opacity: 0;
                    scale: 0.95;
                }
            }
            
            @keyframes jexToastPulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.02); }
            }
            
            .jex-toast-enter {
                animation: jexToastSlideIn var(--duration, 400ms) cubic-bezier(0.68, -0.55, 0.265, 1.55);
            }
            
            .jex-toast-exit {
                animation: jexToastSlideOut var(--duration, 400ms) ease-in;
            }
            
            .jex-toast-pulse {
                animation: jexToastPulse 300ms ease-in-out;
            }
            
            .jex-toast-progress {
                transition: width linear;
            }
        `);
    }

    #createContainer() {
        // Determine position classes
        const positionClasses = this.#getPositionClasses();

        this.#dom.container = jex.create('div')
            .id('jexToastContainer')
            .cls(
                'fixed',
                'z-[10000]',
                'pointer-events-none',
                'flex',
                'flex-col',
                'gap-3',
                'p-4',
                positionClasses,
                this.options.customClass
            )
            .attr('aria-live', 'polite')
            .attr('aria-label', 'Notifications');
    }

    #getPositionClasses() {
        const position = this.options.position;

        switch (position) {
            case 'top-left':
                return 'top-0 left-0 items-start';
            case 'top-right':
                return 'top-0 right-0 items-end';
            case 'bottom-left':
                return 'bottom-0 left-0 items-start';
            case 'bottom-right':
            default:
                return 'bottom-0 right-0 items-end';
        }
    }

    mount() {
        if (!this.#mounted) {
            this.#dom.container.mountToBody();
            this.#mounted = true;
            logger.debug('JexToast mounted');
        }
        return this;
    }

    #createToastElement(message, type) {
        const config = this.options.types[type] || this.options.types.info;
        const isLeft = this.options.position.includes('left');

        // Main toast container
        const toast = jex.create('div')
            .attr('role', 'alert')
            .attr('aria-live', 'assertive')
            .attr('data-type', type)
            .attr('data-message', message)
            .cls(
                'jex-toast',
                'pointer-events-auto',
                'relative',
                'rounded-lg',
                'shadow-lg',
                'border',
                'overflow-hidden',
                'transform-gpu', // Hardware acceleration
                this.options.maxWidth,
                config.bgClass,
                config.borderClass,
                config.textClass
            )
            .style({
                '--slide-from': isLeft ? '-100%' : '100%',
                '--slide-to': isLeft ? '-100%' : '100%',
                '--duration': `${this.options.animationDuration}ms`
            });

        // Content wrapper
        const content = toast.add('div')
            .cls('flex', 'items-start', 'p-4', 'gap-3');

        // Icon
        const icon = content.add('div')
            .cls('flex-shrink-0', 'text-xl', 'leading-none')
            .text(config.icon);

        // Message
        const messageEl = content.add('div')
            .cls('flex-1', 'text-sm', 'font-medium', 'break-words', 'leading-relaxed')
            .text(message);

        // Close button
        const closeBtn = content.add('button')
            .cls(
                'flex-shrink-0',
                'ml-2',
                'text-current',
                'opacity-70',
                'hover:opacity-100',
                'transition-opacity',
                'focus:outline-none',
                'focus:ring-2',
                'focus:ring-white',
                'focus:ring-opacity-50',
                'rounded',
                'w-6',
                'h-6',
                'flex',
                'items-center',
                'justify-center'
            )
            .attr('aria-label', 'Close notification')
            .text('×')
            .on('click', () => this.#removeToast(toast));

        // Progress bar (if enabled)
        let progressBar = null;
        if (this.options.showProgress) {
            progressBar = toast.add('div')
                .cls(
                    'absolute',
                    'bottom-0',
                    'left-0',
                    'h-1',
                    'w-full',
                    'jex-toast-progress',
                    config.progressClass,
                    'opacity-50'
                );
        }

        return { toast, progressBar };
    }

    show(type, message, duration = null) {
        if (!this.#mounted) {
            this.mount();
        }

        const actualDuration = duration !== null ? duration : this.options.duration;

        // Check for duplicates
        if (this.options.detectDuplicates && this.#isDuplicate(type, message)) {
            this.#handleDuplicate(type, message);
            return;
        }

        // Handle queue if max visible reached
        if (this.#visibleToasts >= this.options.maxVisible) {
            if (this.options.queueMessages) {
                this.#queue.push({ type, message, duration: actualDuration });
                return;
            } else {
                // Remove oldest toast
                this.#removeOldestToast();
            }
        }

        this.#showToast(type, message, actualDuration);
    }

    #isDuplicate(type, message) {
        return this.#lastToast &&
            this.#lastToast.type === type &&
            this.#lastToast.message === message &&
            (Date.now() - this.#lastToast.timestamp) < 1000; // 1 second window
    }

    #handleDuplicate(type, message) {
        // Find existing toast and pulse it
        for (const [toastEl, data] of this.#activeToasts) {
            if (data.type === type && data.message === message) {
                toastEl.cls('+jex-toast-pulse');
                setTimeout(() => toastEl.cls('-jex-toast-pulse'), 300);

                // Reset timer
                if (data.timer) {
                    clearTimeout(data.timer);
                }
                data.timer = setTimeout(() => this.#removeToast(toastEl), this.options.duration);
                break;
            }
        }
    }

    #showToast(type, message, duration) {
        const { toast, progressBar } = this.#createToastElement(message, type);

        // Add to container with animation
        toast.cls('+jex-toast-enter');
        this.#dom.container.append(toast);

        // Track toast
        const toastData = {
            type,
            message,
            duration,
            timer: null,
            progressBar
        };

        this.#activeToasts.set(toast, toastData);
        this.#visibleToasts++;
        this.isVisible = true;

        // Update last toast reference
        this.#lastToast = {
            type,
            message,
            timestamp: Date.now()
        };

        // Setup auto-removal timer
        if (duration > 0) {
            toastData.timer = setTimeout(() => {
                this.#removeToast(toast);
            }, duration);

            // Animate progress bar
            if (progressBar) {
                setTimeout(() => {
                    progressBar.style({
                        width: '0%',
                        transitionDuration: `${duration}ms`
                    });
                }, 50);
            }
        }

        // Remove enter animation class
        setTimeout(() => {
            toast.cls('-jex-toast-enter');
        }, this.options.animationDuration);

        logger.debug(`Toast shown: ${type} - ${message}`);
    }

    #removeToast(toastElement) {
        const toastData = this.#activeToasts.get(toastElement);
        if (!toastData) return;

        // Clear timer
        if (toastData.timer) {
            clearTimeout(toastData.timer);
        }

        // Add exit animation
        toastElement.cls('+jex-toast-exit');

        // Remove after animation
        setTimeout(() => {
            toastElement.remove();
            this.#activeToasts.delete(toastElement);
            this.#visibleToasts--;

            // Update visibility state
            if (this.#visibleToasts === 0) {
                this.isVisible = false;
            }

            // Process queue
            this.#processQueue();
        }, this.options.animationDuration);
    }

    #removeOldestToast() {
        const oldestToast = this.#activeToasts.keys().next().value;
        if (oldestToast) {
            this.#removeToast(oldestToast);
        }
    }

    #processQueue() {
        if (this.#queue.length > 0 && this.#visibleToasts < this.options.maxVisible) {
            const { type, message, duration } = this.#queue.shift();
            this.#showToast(type, message, duration);
        }
    }

    // Convenience methods
    success(message, duration) {
        logger.info(`Toast Success: ${message}`);
        this.show('success', message, duration);
    }

    error(message, duration) {
        logger.error(`Toast Error: ${message}`);
        this.show('error', message, duration);
    }

    warning(message, duration) {
        logger.warn(`Toast Warning: ${message}`);
        this.show('warning', message, duration);
    }

    info(message, duration) {
        this.show('info', message, duration);
    }

    command(message, duration) {
        this.show('command', message, duration);
    }

    check(condition, errorMessage, callback = null) {
        if (!condition) {
            this.error(errorMessage);
            return false;
        }

        if (typeof callback === 'function') {
            callback(condition);
        }

        return true;
    }

    clearAll() {
        // Clear all timers
        for (const toastData of this.#activeToasts.values()) {
            if (toastData.timer) {
                clearTimeout(toastData.timer);
            }
        }

        // Clear queue
        this.#queue = [];

        // Remove all toasts
        this.#dom.container?.clear();

        // Reset state
        this.#activeToasts.clear();
        this.#visibleToasts = 0;
        this.#lastToast = null;
        this.isVisible = false;
    }

    destroy() {
        this.clearAll();

        if (this.#mounted) {
            this.#dom.container?.remove();
            this.#mounted = false;
        }

        jex.remove('jexToastStyles');

        logger.debug('JexToast destroyed');
    }
}

// Create and export global instance
export const toast = new JexToast();


================================================================================
FILE: README.md
Type: MD
Size: 5.74 KB
Last Modified: 2025-09-12T08:00:45.449Z
Lines: 194
MD5: 8952a493b0375e1dac20981d4b9e92bb
================================================================================

# Jex.js

<img src="https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/jex-logo.svg" alt="Jex.js Logo" width="200" />

> Lightweight DOM manipulation library with jQuery-like syntax and zero dependencies

## Features

- **Zero dependencies** - Pure JavaScript, no external requirements
- **Small footprint** - ~15KB minified, optimized for performance
- **jQuery-like syntax** - Familiar API for easy adoption
- **Method chaining** - Fluent interface for cleaner code
- **Modern ES6+** - Class-based architecture with full JSDoc support
- **Universal** - Works with HTML, SVG elements, and all modern browsers

## Quick Start

```javascript
import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';

// Element selection and manipulation
jex.$('myButton').cls('+active').text('Click me!');

// Create and mount elements
jex.create('div')
  .cls('+container +p-4')
  .html('<h1>Hello World!</h1>')
  .mountToBody();

// Event handling with cleanup
const cleanup = jex.onDocument('click', (e) => console.log('Clicked!'));
```

## Core API

### Selection & Creation
```javascript
jex.$('elementId')                // Select by ID → Jex | null
jex.$('?elementId')               // Check existence → boolean
jex.select('.class')              // First match → Jex | null
jex.find('.items')                // All matches → JexCollection
jex.create('div', 'myId')         // Create element → Jex
```

### Content & Attributes
```javascript
element.text('content')           // Set/get text
element.html('<p>content</p>')    // Set/get HTML
element.value('input value')      // Set/get form values
element.attr('id', 'value')       // Set/get attributes
element.data('key', 'value')      // Set/get data-* attributes
```

### Classes & Styling
```javascript
element.cls('+add -remove ~toggle')  // Class manipulation
element.cls('?exists')               // Check class → boolean
element.style({color: 'red'})        // Set styles
element.show() / element.hide()      // Visibility
```

### DOM Manipulation
```javascript
element.append(child1, child2)    // Add children
element.prepend(content)          // Add at start
element.mount(parent)             // Mount to parent
element.remove()                  // Remove from DOM
element.clear()                   // Clear children
```

### Events
```javascript
element.on('click', handler)         // Add listener
element.onClick(handler)             // Convenient click
element.delegate('click', '.btn', handler)  // Event delegation
jex.onDocument('keydown', handler)   // Global document events
jex.onKey('Ctrl+K', handler)         // Keyboard shortcuts
```

### Navigation
```javascript
element.parent()                  // Get parent → Jex
element.siblings()                // Get siblings → JexCollection  
element.next() / element.prev()   // Adjacent siblings → Jex
element.closest('.selector')      // Find ancestor → Jex
```

## Collections

Multi-element operations return `JexCollection` with batch methods:

```javascript
jex.find('.buttons')
  .cls('+styled')
  .on('click', handler)
  .style({opacity: '0.8'});

// Access individual elements
const items = jex.find('.item');
items.first().cls('+first');
items.last().cls('+last');
```

## Complete Example

```javascript
import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';

// Create a modal dialog
function createModal(title, message) {
  return jex.create('div')
    .cls('+fixed +inset-0 +bg-black +bg-opacity-50 +flex +items-center +justify-center +z-50')
    .append(
      jex.create('div')
        .cls('+bg-white +p-6 +rounded-lg +max-w-md +w-full +mx-4')
        .append(
          jex.create('h2').text(title).cls('+text-xl +font-bold +mb-4'),
          jex.create('p').text(message).cls('+text-gray-600 +mb-6'),
          jex.create('button')
            .text('Close')
            .cls('+px-4 +py-2 +bg-blue-500 +text-white +rounded +hover:bg-blue-600')
            .onClick(() => modal.remove())
        )
    )
    .onClick((e) => e.target === modal.ref && modal.remove())
    .mountToBody();
}

// Usage
const modal = createModal('Success', 'Operation completed successfully!');
```

## Installation

### CDN (Recommended)
```html
<script type="module">
  import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';
  // Your code here
</script>
```

### Download
```bash
# Download individual files
wget https://raw.githubusercontent.com/Bloechle/jex/main/Jex.js

# Or clone the repository
git clone https://github.com/Bloechle/jex.git
```

### Import
```javascript
// ES6 modules
import { jex, Jex, JexCollection } from './Jex.js';

// Or from CDN
import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';
```

## Ecosystem

The Jex framework includes additional components:

- **JexLogger.js** - Advanced console and logging system
- **JexInspector.js** - Visual DOM element inspector
- **JexToast.js** - Toast notification system

```javascript
// Use the complete ecosystem
import { jex } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/Jex.js';
import { logger } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/JexLogger.js';
import { toast } from 'https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/JexToast.js';

logger.info('Application started');
toast.success('Welcome to Jex.js!');
```

## Browser Support

- **Chrome/Edge**: 80+
- **Firefox**: 75+
- **Safari**: 13+
- **Mobile**: iOS 13+, Android 8+

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Links

- **Repository**: https://github.com/Bloechle/jex
- **Issues**: https://github.com/Bloechle/jex/issues
- **CDN**: https://cdn.jsdelivr.net/gh/Bloechle/jex@latest/

## 6. Table of Contents

| File | Type | Size | Lines |
|------|------|------|-------|
| Jex.js | JS | 31.59 KB | 1027 |
| JexInspector.js | JS | 17.51 KB | 526 |
| JexLogger.js | JS | 24.11 KB | 704 |
| JexToast.js | JS | 16.27 KB | 538 |
| README.md | MD | 5.74 KB | 194 |


## 7. Summary Report

### Statistics
- **Files Processed:** 5
- **Files Skipped:** 73
- **Total Size:** 95.21 KB
- **Total Lines:** 2’989
- **Processing Time:** 0.21 seconds
- **Errors:** 0
- **Warnings:** 0

### File Type Distribution
- **JS:** 4 files (80.0%)
- **MD:** 1 files (20.0%)

### Largest Files
1. Jex.js - 31.59 KB
2. JexLogger.js - 24.11 KB
3. JexInspector.js - 17.51 KB
4. JexToast.js - 16.27 KB
5. README.md - 5.74 KB

